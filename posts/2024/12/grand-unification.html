<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-12-08">

<title>An Attempt at Understanding the Grand Unification – Ali ALMASI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon-96x96.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-a34f4369a49b65e96a3454786cbeafca.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
@import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap')
@import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap')
</style>
<script>
MathJax = {
    tex: {
        tags: 'all'  // should be 'ams', 'none', or 'all'
    },
    output: {
        font: 'mathjax-fira'
    }
};
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@4.0.0-beta.4/tex-mml-chtml.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="An Attempt at Understanding the Grand Unification – Ali ALMASI">
<meta property="og:description" content="">
<meta property="og:site_name" content="Ali ALMASI">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Ali ALMASI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../misc.html"> 
<span class="menu-text">Misc.</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#block-encoding" id="toc-block-encoding" class="nav-link" data-scroll-target="#block-encoding"><span class="header-section-number">2</span> Block-Encoding</a></li>
  <li><a href="#quantum-signal-processing-qsp" id="toc-quantum-signal-processing-qsp" class="nav-link" data-scroll-target="#quantum-signal-processing-qsp"><span class="header-section-number">3</span> Quantum Signal Processing (QSP)</a></li>
  <li><a href="#proof-of-the-qsp-theorem" id="toc-proof-of-the-qsp-theorem" class="nav-link" data-scroll-target="#proof-of-the-qsp-theorem"><span class="header-section-number">4</span> Proof of the QSP Theorem</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">An Attempt at Understanding the Grand Unification</h1>
  <div class="quarto-categories">
    <div class="quarto-category">quantum-algorithms</div>
    <div class="quarto-category">course-notes</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 8, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>

<nav id="TOC-body" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#block-encoding" id="toc-block-encoding"><span class="header-section-number">2</span> Block-Encoding</a></li>
  <li><a href="#quantum-signal-processing-qsp" id="toc-quantum-signal-processing-qsp"><span class="header-section-number">3</span> Quantum Signal Processing (QSP)</a></li>
  <li><a href="#proof-of-the-qsp-theorem" id="toc-proof-of-the-qsp-theorem"><span class="header-section-number">4</span> Proof of the QSP Theorem</a></li>
  </ul>
</nav>
<p><span style="color:green;font-weight:700;font-size:12px"> It’s unfortunate that there aren’t many good open-source fonts designed specifically for dyslexic readers. However, there’s a helpful <a href="https://chromewebstore.google.com/detail/opendyslexic-for-chrome/cdnapgfjopgaggbmfgbiinmmbdcglnam?pli=1">Chrome extension</a> that can change the font of the text you read online, making it easier to follow.</span></p>
<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p>There are roughly two main lines of designing quantum algorithms, and many of the algorithms we know today can be classified under one of these two categories. The representative algorithm of the first category is the Grover’s search algorithm, and the second category is represented by the Shor’s factoring algorithm [One may even argue that Shor’s algorithm is not that different from Grover’s algorithm.]. It is a natural question then to ask what is the underlying technique that unifies all these algorithms. This is the main claim of the “The Grand Unification” paper: Finding the common underlying technique that unifies all quantum algorithms.</p>
</section>
<section id="block-encoding" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="block-encoding"><span class="header-section-number">2</span> Block-Encoding</h2>
<p>In block-encoding, we want to encode an arbitrary matrix <span class="math inline">\(A \in \mathbb{C}^{r \times c}\)</span> in a unitary matrix <span class="math inline">\(U \in \mathbb{C}^{d \times d}\)</span>, in a way that the top-left <span class="math inline">\(r \times c\)</span> block of <span class="math inline">\(U\)</span> is <span class="math inline">\(A\)</span>. This condition can be formulated as</p>
<p><span class="math display">\[ I_{r,d} U I_{d,c} = A, \]</span></p>
<p>where <span class="math inline">\(I_{r,d}\)</span> is first <span class="math inline">\(r\)</span> rows of the identity matrix of size <span class="math inline">\(d \times d\)</span>, and <span class="math inline">\(I_{d,c}\)</span> is the first <span class="math inline">\(c\)</span> columns of the identity matrix of size <span class="math inline">\(d \times d\)</span>.</p>
<p>Let us think of the matrix <span class="math inline">\(A\)</span> as an operator acting on a <span class="math inline">\(s\)</span>-qubit system (you may think of <span class="math inline">\(A\)</span> as a Hamiltonian acting on <span class="math inline">\(s\)</span> qubits.), and <span class="math inline">\(U\)</span> as a unitary acting on the <span class="math inline">\(k\)</span>-qubit system plus an ancilla <span class="math inline">\(a\)</span>-qubit register. Then, <span class="math inline">\(U\)</span> is a block-encoding of <span class="math inline">\(A\)</span> if</p>
<p><span class="math display">\[ \left( \bra{0}^{\otimes a} \otimes I_{2^k} \right) U \left( \ket{0}^{\otimes a} \otimes I_{2^k} \right) = A. \]</span></p>
<p>An example of a block-encoding is the following:</p>
<p>Suppose that we have a control-qubit <span class="math inline">\(C\)</span> and a target-system <span class="math inline">\(T\)</span> with Hilbert space <span class="math inline">\(\mathcal{H}_T\)</span>, and there is a Hermitian operator <span class="math inline">\(H\)</span> acting on the target-system. The following is a block-encoding of <span class="math inline">\(H\)</span>:</p>
<p><span class="math display">\[ U = \ket{0}\bra{0}_C \otimes H_T + \ket{0}\bra{1}_C \otimes \sqrt{I - H^2}_T + \ket{1}\bra{0}_C \otimes \sqrt{I - H^2}_T + \ket{1}\bra{1}_C \otimes -H_T, \]</span></p>
<p>when <span class="math inline">\(\| H \| \leq 1\)</span>.</p>
<p>Having the spectral decomposition of <span class="math inline">\(H\)</span> as</p>
<p><span class="math display">\[ H = \sum_{i} \lambda_i \ket{\lambda_i}\bra{\lambda_i}, \]</span></p>
<p>we can also write <span class="math inline">\(U\)</span> as</p>
<p><span class="math display">\[ U = \sum_{i} \left( \ket{0}\bra{0}_C \lambda_i + \ket{0}\bra{1}_C \sqrt{1 - \lambda_i^2} + \ket{1}\bra{0}_C \sqrt{1 - \lambda_i^2} - \ket{1}\bra{1}_C \lambda_i \right) \otimes \ket{\lambda_i}\bra{\lambda_i}_T, \]</span></p>
<p>which can be written in the matrix form as</p>
<p><span class="math display">\[ U = \sum_{i=1}^{\dim(\mathcal{H}_T)} \begin{bmatrix} \lambda_i &amp; \sqrt{1 - \lambda_i^2} \\ \sqrt{1 - \lambda_i^2} &amp; -\lambda_i \end{bmatrix} \otimes \ket{\lambda_i}\bra{\lambda_i}. \]</span></p>
<p>Block-encodings are in some sense a generalization of unitary operations, in the sense that if <span class="math inline">\(U\)</span> is a block-encoding of <span class="math inline">\(H\)</span>, then by applying <span class="math inline">\(U\)</span> on the state <span class="math inline">\(\ket{0}^{\otimes a} \otimes \ket{\psi}\)</span>, and then measuring the ancilla register, we obtain the state <span class="math inline">\(\frac{H\ket{\psi}}{\|H\ket{\psi}\|}\)</span> with probability <span class="math inline">\(\|H\ket{\psi}\|^2\)</span>.</p>
<p>Now suppose that we have access to a block-encoding of <span class="math inline">\(H\)</span>. Consider a matrix <span class="math inline">\(A\)</span> that is a function of <span class="math inline">\(H\)</span>, say <span class="math inline">\(A = f(H)\)</span>. Can we find a block-encoding of <span class="math inline">\(A\)</span>?</p>
</section>
<section id="quantum-signal-processing-qsp" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="quantum-signal-processing-qsp"><span class="header-section-number">3</span> Quantum Signal Processing (QSP)</h2>
<p>Let us start with the simplest case: consider your matrix <span class="math inline">\(H\)</span> to be a <span class="math inline">\(1\times 1\)</span> matrix, i.e., a scalar <span class="math inline">\(a \in [-1,1]\)</span>. The following unitary is a block-encoding of <span class="math inline">\(H\)</span> (this gate )</p>
<p><span class="math display">\[ R(a) = \begin{bmatrix} a &amp; \sqrt{1 - a^2} \\ \sqrt{1 - a^2} &amp; -a \end{bmatrix}. \]</span></p>
<p>We prefer to continue with a slightly modified version of <span class="math inline">\(R(a)\)</span>, which we call <span class="math inline">\(W(a)\)</span>:</p>
<p><span class="math display">\[ W(a) = \begin{bmatrix} a &amp; i\sqrt{1 - a^2} \\ i\sqrt{1 - a^2} &amp; a \end{bmatrix}. \]</span></p>
<p>You can easily verify that</p>
<p><span class="math display">\[ W(a) = i \begin{bmatrix} e^{-i\frac{\pi}{4}} &amp; 0 \\ 0 &amp; e^{i\frac{\pi}{4}} \end{bmatrix} R(a) \begin{bmatrix} e^{-i\frac{\pi}{4}} &amp; 0 \\ 0 &amp; e^{i\frac{\pi}{4}} \end{bmatrix}. \]</span></p>
<p>This unitary can be seen as a rotation of the Bloch sphere around the <span class="math inline">\(X\)</span>-axis by an angle <span class="math inline">\(-2\arccos(a)\)</span>.</p>
<p>Now, assume that we have also access to another unitary <span class="math inline">\(S(\phi)\)</span>, that realizes a rotation with angle <span class="math inline">\(-2\phi\)</span> around the <span class="math inline">\(Z\)</span>-axis, which means that</p>
<p><span class="math display">\[ S(\phi) = \begin{bmatrix} e^{i\phi} &amp; 0 \\ 0 &amp; e^{-i\phi} \end{bmatrix}. \]</span></p>
<p>This latter unitary is in fact a family of unitaries, giving a gate <span class="math inline">\(S(\phi)\)</span> for each <span class="math inline">\(\phi \in [0,2\pi]\)</span>.</p>
<p>Now, the question is, “having access to <span class="math inline">\(W(a)\)</span> and <span class="math inline">\(S(\phi)\)</span>, what sort of unitaries can we construct?”. In other words, if for <span class="math inline">\(\phi = (\phi_0, \phi_1, \dots, \phi_{d})\)</span>, we define</p>
<p><span class="math display">\[ U_{\phi} = S(\phi_0) \Pi_{i=1}^{d} W(a) S(\phi_i), \]</span></p>
<p>then, how can we characterize the set of unitaries <span class="math inline">\(U_{\phi}\)</span>?</p>
<p>The answer to this question is given by the main theorem of Quantum Signal Processing (QSP), which is as follows:</p>
<p><strong>Theorem (QSP)</strong>: A QSP sequence as defined above can be expressed as</p>
<p><span class="math display">\[ \begin{bmatrix} P(a) &amp; iQ(a)\sqrt{1 - a^2} \\ iQ^*(a)\sqrt{1 - a^2} &amp; P^*(a) \end{bmatrix}, \]</span></p>
<p>for <span class="math inline">\(a \in [-1,1]\)</span>, where <span class="math inline">\(P(a)\)</span> and <span class="math inline">\(Q(a)\)</span> are polynomials satisfying 1. <span class="math inline">\(\deg(P) \leq d\)</span>, and <span class="math inline">\(\deg(Q) \leq d-1\)</span>, 2. <span class="math inline">\(P\)</span> has parity <span class="math inline">\(d \mod 2\)</span> and <span class="math inline">\(Q\)</span> has parity <span class="math inline">\((d-1) \mod 2\)</span>, 3. For all <span class="math inline">\(a \in [-1,1]\)</span>, <span class="math inline">\(\vert P(a)\vert^2 + (1 - a^2)\vert Q(a)\vert^2 = 1\)</span>.</p>
<p>Moreover, for any <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> satisfying the above conditions, there exists a QSP sequence realizing the above unitary.</p>
<p>As you can see, in this simple case, we have a rather neat characterization of achievable functions of <span class="math inline">\(H\)</span>, which was the matrix whose block-encoding we had access to.</p>
<p>You may wonder if we can get rid of the dependency to <span class="math inline">\(Q\)</span> in the third condition. To this end, you can instead consider the possible transformations on the subspace spanned by <span class="math inline">\(\ket{+}\)</span>, since</p>
<p><span class="math display">\[ \bra{+} \begin{bmatrix} P(a) &amp; iQ(a)\sqrt{1 - a^2} \\ iQ^*(a)\sqrt{1 - a^2} &amp; P^*(a) \end{bmatrix} \ket{+} = \operatorname{Re}(P(a)) + \operatorname{Re}(Q(a))i\sqrt{1 - a^2}. \]</span></p>
<p>This implies that for any <em>real</em> polynomial <span class="math inline">\(P\)</span> of degree at most <span class="math inline">\(d\)</span> that has parity <span class="math inline">\(d \mod 2\)</span>, and for any <span class="math inline">\(a \in [-1,1]\)</span>, <span class="math inline">\(\vert P(a)\vert \leq 1\)</span>, there exists a QSP sequence realizing this polynomial on the subspace spanned by <span class="math inline">\(\ket{+}\)</span>.</p>
</section>
<section id="proof-of-the-qsp-theorem" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="proof-of-the-qsp-theorem"><span class="header-section-number">4</span> Proof of the QSP Theorem</h2>
<section id="proof-of-the-direct-part" class="level5">
<h5 class="anchored" data-anchor-id="proof-of-the-direct-part">Proof of the Direct Part</h5>
<p>We first prove by induction that (1) and (2) hold for any QSP sequence. Let <span class="math inline">\(U_{\phi} = S(\phi_0) \Pi_{i=1}^{d} W(a) S(\phi_i)\)</span>. For <span class="math inline">\(d = 0\)</span>, we have</p>
<p><span class="math display">\[U_{\phi} = S(\phi_0) = \begin{bmatrix} e^{i\phi_0} &amp; 0 \\ 0 &amp; e^{-i\phi_0} \end{bmatrix}, \]</span></p>
<p>and we see that <span class="math inline">\(P(a) = e^{i\phi_0}\)</span> and <span class="math inline">\(Q(a) = 0\)</span>, which are polynomials of degree <span class="math inline">\(0\)</span> and <span class="math inline">\(-\infty\)</span>, and parity <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, respectively.</p>
<p>Now, assume that the conditions hold for <span class="math inline">\(d=k-1\)</span>. For <span class="math inline">\(d=k\)</span>, we have</p>
<p><span class="math display">\[ \begin{align}
U_{\phi} &amp;= \left( S(\phi_0) \Pi_{i=1}^{k-1} W(a) S(\phi_i) \right) W(a) S(\phi_k)\\
&amp;= \begin{bmatrix} \widetilde{P}(a) &amp; i\widetilde{Q}(a)\sqrt{1 - a^2} \\ i\widetilde{Q}^*(a)\sqrt{1 - a^2} &amp; \widetilde{P}^*(a) \end{bmatrix} \begin{bmatrix} a e^{i\phi_k} &amp; i\sqrt{1 - a^2} e^{-i\phi_k} \\ i\sqrt{1 - a^2} e^{i\phi_k} &amp; a e^{-i\phi_k} \end{bmatrix}\\
&amp;= \begin{bmatrix} \widetilde{P}(a) a e^{i\phi_k} - \widetilde{Q}(a)(1-a^2)e^{i\phi_k} &amp; i\widetilde{P}(a)\sqrt{1 - a^2} e^{-i\phi_k} + i\widetilde{Q}(a)a\sqrt{1 - a^2} e^{-i\phi_k} \\ i\widetilde{Q}^*(a)a\sqrt{1 - a^2} e^{i\phi_k} + i\widetilde{P}^*(a)\sqrt{1 - a^2} e^{i\phi_k} &amp; -\widetilde{Q}^*(a)(1 - a^2)e^{-i\phi_k} + \widetilde{P}^*(a)a e^{-i\phi_k} \end{bmatrix}.
\end{align} \]</span></p>
<p>Defining</p>
<p><span class="math display">\[ P(a) = \widetilde{P}(a) a e^{i\phi_k} - \widetilde{Q}(a)(1-a^2)e^{i\phi_k},\]</span></p>
<p>and</p>
<p><span class="math display">\[ Q(a) = \widetilde{P}(a)e^{-i\phi_k} + \widetilde{Q}(a)a e^{-i\phi_k}, \]</span></p>
<p>we see that <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are polynomials of degree at most <span class="math inline">\(k\)</span> and <span class="math inline">\(k-1\)</span>, and that the parity of <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are the opposite of the parity of <span class="math inline">\(\widetilde{P}\)</span> and <span class="math inline">\(\widetilde{Q}\)</span>, respectively.</p>
<p>Finally, we note that since <span class="math inline">\(U_{\phi}\)</span> is a unitary, we have <span class="math inline">\(\vert P(a)\vert^2 + (1 - a^2)\vert Q(a)\vert^2 = 1\)</span>.</p>
</section>
<section id="proof-of-the-converse-part" class="level5">
<h5 class="anchored" data-anchor-id="proof-of-the-converse-part">Proof of the Converse Part</h5>
<p>For the converse part, let us assume that</p>
<p><span class="math display">\[ T = \begin{bmatrix} P(a) &amp; iQ(a)\sqrt{1 - a^2} \\ iQ^*(a)\sqrt{1 - a^2} &amp; P^*(a) \end{bmatrix}, \]</span></p>
<p>where <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are polynomials satisfying (1), (2), and (3), for some <span class="math inline">\(d\)</span>. We want to show that a vector of angles <span class="math inline">\(\phi = (\phi_0, \phi_1, \dots, \phi_d)\)</span> exists such that <span class="math inline">\(U_{\phi} = T\)</span>.</p>
<p>We prove this by induction on <span class="math inline">\(\deg(P)\)</span>. For <span class="math inline">\(\deg(P) = 0\)</span>, <span class="math inline">\(P\)</span> is a constant, and for <span class="math inline">\(a \in [-1,1]\)</span>, <span class="math inline">\(P(a) = P(1)\)</span>. From (3), we have <span class="math inline">\(\vert P(1)\vert = 1\)</span>, and since for infinitely many <span class="math inline">\(a \in [-1,1]\)</span>, <span class="math inline">\(\vert Q(a)\vert^2 (1 - a^2) = 0\)</span>, by the fundamental theorem of algebra, we conclude that <span class="math inline">\(Q(a) = 0\)</span>. Since <span class="math inline">\(\vert P(a)\vert = 1\)</span>, <span class="math inline">\(P(a) = e^{i\phi_0}\)</span> for some <span class="math inline">\(\phi_0\)</span>, and we have <span class="math inline">\(T = S(\phi_0)\)</span>.</p>
<p>To choose the rest of the angles, it is easy to see that no matter what the value of <span class="math inline">\(a\)</span> is, we always have</p>
<p><span class="math display">\[ W(a) S(\frac{\pi}{2}) W(a) S(-\frac{\pi}{2}) = I. \]</span></p>
<p>You can either verify this by direct calculation, or try to convince yourself geometrically by noting that <span class="math inline">\(W(a)\)</span> is a rotation around the <span class="math inline">\(X\)</span>-axis by some angle <span class="math inline">\(\theta\)</span>, and <span class="math inline">\(S(\frac{\pi}{2})\)</span> and <span class="math inline">\(S(-\frac{\pi}{2})\)</span> are rotations around the <span class="math inline">\(Z\)</span>-axis by <span class="math inline">\(-\pi\)</span> and <span class="math inline">\(\pi\)</span>, respectively.</p>
<p>Finally, we note that <span class="math inline">\(P\)</span> is a non-zero constant, thus its parity is even, and since (2) holds, <span class="math inline">\(d\)</span> is even. Thus, we can set <span class="math inline">\(\phi_{2i+1} = \pi/2\)</span> and <span class="math inline">\(\phi_{2i} = -\pi/2\)</span> for <span class="math inline">\(i = 0,1,\dots,d/2\)</span>, resulting in <span class="math inline">\(U_{\phi} = T\)</span>.</p>
<p>Now, assume that the statement holds for <span class="math inline">\(\deg(P) \leq k-1\)</span>. Consider <span class="math inline">\(T\)</span> with polynomial <span class="math inline">\(P\)</span> of degree <span class="math inline">\(k &gt; 0\)</span>.</p>
<p><strong>Lemma</strong>: If <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> satisfy (3), and <span class="math inline">\(\deg(P) = k &gt; 0\)</span>, then <span class="math inline">\(\deg(Q) = k-1\)</span>, and the leading coefficients of <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> have the same modulus.</p>
<p><strong>Proof of the Lemma</strong>: Let us write <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> as</p>
<p><span class="math display">\[ P(a) = \sum_{i=0}^{k} p_i a^i, \quad Q(a) = \sum_{i=0}^{k-1} q_i a^i, \]</span></p>
<p>where <span class="math inline">\(p_k \neq 0\)</span>. From (3), we have</p>
<p><span class="math display">\[ \vert P(a)\vert^2 + (1 - a^2)\vert Q(a)\vert^2 = 1, \]</span></p>
<p>for all <span class="math inline">\(a \in [-1,1]\)</span>. The coefficients of the non-constant terms of the left-hand side have to be zero, thus <span class="math inline">\(\deg(Q) \leq k-1\)</span>. Moreover, the coefficient of <span class="math inline">\(a^{2k}\)</span> in the left-hand side is <span class="math inline">\(\vert p_k\vert^2 - \vert q_{k-1}\vert^2\)</span>, which has to be zero. This implies that <span class="math inline">\(\deg(Q) = k-1\)</span>, and <span class="math inline">\(\vert p_k\vert = \vert q_{k-1}\vert\)</span>.</p>
<p>Consider the matrix</p>
<p><span class="math display">\[ T W(a)^\dagger S(\phi_{d})^\dagger, \]</span></p>
<p>which can be written as</p>
<p><span class="math display">\[ \begin{align}
T W(a)^\dagger S(\phi_{d})^\dagger &amp;= \begin{bmatrix} P(a) &amp; iQ(a)\sqrt{1 - a^2} \\ iQ^*(a)\sqrt{1 - a^2} &amp; P^*(a) \end{bmatrix} \begin{bmatrix} a e^{-i\phi_d} &amp; -i\sqrt{1 - a^2} e^{-i\phi_d} \\ -i\sqrt{1 - a^2} e^{i\phi_d} &amp; a e^{i\phi_d} \end{bmatrix}\\
&amp;= \begin{bmatrix} P(a) a e^{-i\phi_d} + Q(a)(1 - a^2)e^{i \phi_d} &amp; i\sqrt{1 - a^2} \left(- P(a) e^{-i\phi_d} + Q(a) a e^{i\phi_d} \right) \\ i\sqrt{1 - a^2} \left(- P^*(a) e^{i\phi_d} + Q^*(a) a e^{-i\phi_d} \right) &amp; P^*(a) a e^{i\phi_d} + Q^*(a)(1 - a^2)e^{-i \phi_d} \end{bmatrix}.
\end{align} \]</span></p>
<p>We can choose <span class="math inline">\(\phi_d\)</span> such that <span class="math inline">\(e^{2i\phi_d} = \frac{p_k}{q_{k-1}}\)</span> (From the Lemma, we know that this is possible). Then, the <span class="math inline">\(a^{k+1}\)</span> term in <span class="math inline">\(P(a) a e^{-i\phi_d} + Q(a)(1 - a^2)e^{i \phi_d}\)</span> will have a coefficient equal to zero, and since the parity of <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> are <span class="math inline">\(d \mod 2\)</span> and <span class="math inline">\((d-1) \mod 2\)</span>, respectively, the coefficient of the <span class="math inline">\(a^{k-1}\)</span> in <span class="math inline">\(P(a)\)</span> and <span class="math inline">\(a^{k-2}\)</span> in <span class="math inline">\(Q(a)\)</span> is zero, implying that <span class="math inline">\(P(a) a e^{-i\phi_d} + Q(a)(1 - a^2)e^{i \phi_d}\)</span> is a polynomial of degree at most <span class="math inline">\(k-2\)</span>. Similarly, by taking the same <span class="math inline">\(\phi_d\)</span>, <span class="math inline">\(P(a) e^{-i \phi_d} + a e^{i\phi_d} Q(a)\)</span> will be a polynomial of degree at most <span class="math inline">\(k-2\)</span>. Moreover, the parity of <span class="math inline">\(P(a) a e^{-i\phi_d} + Q(a)(1 - a^2)e^{i \phi_d}\)</span> and <span class="math inline">\(P(a) e^{-i \phi_d} + a e^{i\phi_d} Q(a)\)</span> are <span class="math inline">\(d-1 \mod 2\)</span> and <span class="math inline">\(d - 2 \mod 2\)</span>, respectively. Finally, <span class="math inline">\(T W(a)^\dagger S(\phi_{d})^\dagger\)</span> is also a unitary, and the third condition is preserved for the new polynomials.</p>
<p>By the induction hypothesis, we can find <span class="math inline">\(\phi_0, \phi_1, \dots, \phi_{d-1}\)</span> such that $T W(a)^S(_{d})^$ is a QSP sequence with the corresponding angles. By right-multiplying this unitary with <span class="math inline">\(W(a) S(\phi_d)\)</span>, we obtain <span class="math inline">\(T\)</span> as a QSP sequence with angles <span class="math inline">\(\phi_0, \phi_1, \dots, \phi_{d}\)</span>.</p>
<p>The above proof gives a constructive way of finding the angles <span class="math inline">\(\phi\)</span> for given polynomials <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> satisfying the conditions of the QSP theorem, and this vector of angles can be computed in time <span class="math inline">\(O(d^2)\)</span>.</p>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ali-almasi\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Die Mathematiker sind eine Art Franzosen. Spricht man zu ihnen, so übersetzen sie alles in ihre eigene Sprache, und so wird es alsobald etwas ganz anderes. -Goethe
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>